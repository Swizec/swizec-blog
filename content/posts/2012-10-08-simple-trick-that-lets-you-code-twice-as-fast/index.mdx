---
layout: post
title: Simple trick that lets you code twice as fast
date: 2012-10-08
categories: Automation, Programming, Quality assurance, Test automation, Test suite
author: Swizec Teller
hero: ./img/mocha-testing.png
---

\[caption id="" align="alignnone" width="438" caption="Basic idea from THE Bret Victor talk"]![Basic idea from THE Bret Victor talk](http://icant.co.uk/talks/h5/pictures/smashingconf/shorterjourney.jpg "Basic idea from THE Bret Victor talk")\[/caption] Immediate feedback. No really, it's that simple. Most of our a developer's revolves around verifying code. After [hitting the limit of how fast you can type](http://swizec.com/blog/ive-hit-a-glass-ceiling-of-coding-productivity-now-what/swizec/5191 "Iâ€™ve hit a glass ceiling of coding productivity. Now what?"), the only way to think faster is getting feedback instantly. There's actually two parts to this trick.

## 1. Automated testing

First of all, you should write tests. No need for full on TDD writing tests before writing code, just have tests, _any_ tests. Because eventually you will want to know if this thing you've just coded works. Your first test is: does it run? \[caption id="attachment_5386" align="alignright" width="307" caption="Mocha automated automated testing"][![Mocha automated automated testing](http://swizec.com/blog/wp-content/uploads/2012/10/mocha-testing.png "Mocha automated automated testing")](./img/mocha-testing.png)\[/caption] The next test is: does it do what it's supposed to? Without an automated [test suite](http://en.wikipedia.org/wiki/Test_suite "Test suite") this one is tricky. It takes _ages_. _Decades_compared to how easy it was to write. At worst, you have to check your whole program after every change. Good design alleviates a lot of this burden due to isolation, but still ... effort. I still remember when every change meant some 20 minutes of clicking around to check if things worked. And I only remembered to click around the thing I just changed, never you mind any ripple effects in the codebase. Horror. Automated testing reduces those 20 minutes to, say, 30 seconds. Your life becomes:

1.  Write some code
2.  Hop into a console of some sort
3.  Possibly compile things
4.  Run the test suite
5.  Wait while it runs
6.  Give in to the urge to quickly check twitterredditfacebooksomething
7.  Go back to coding long after the tests finished

Great, it's just taken a minute (not counting twitterredditfacebooksomething time) to find out if something works. I do this every ~5 minutes, that means a waste of 10 minutes per every hour worked.

## 2. Automated automated testing

One hour and twenty minutes every full workday. Man, that's some non-negligible time right there! Then again, I've got an automated test suite, why am I running it manually? Wouldn't it be better if something ran the test suite every time I hit _Ctrl+S_? And that's exactly how it's supposed to be! Let [automated testing](http://en.wikipedia.org/wiki/Test_automation "Test automation") run automatically and just glance at the results every so often. You won't break concentration, you won't be tempted to check twitter while the tests run, you won't have to get out of your [text editor](http://en.wikipedia.org/wiki/Text_editor "Text editor"). Win-win-win. Right now I use two tools to do this (and am looking for more) [Mocha](http://visionmedia.github.com/mocha/)'s got a wonderful _-w_ option for running node.js tests - it watches files for changes and reruns the suite every time you save. And Mocha is just generally wonderful, but that's a different post. For frontend development, I'm using _[Live CSS Mod](https://chrome.google.com/webstore/detail/live-css-mod/pcfngkdgaccedbamgamojgomaibafdcg) -_a Chrome extension, which refreshes a page every couple of seconds. But it's smart enough to do this in the background and only show the changes if there's anything different. This means you don't lose state all the time because that would be annoying. Now all I need are these sorts of tools for the other stacks I'm using. (Django/python and Haskell).

###### Related articles

-   [![](http://i.zemanta.com/noimg_124_80_80.jpg)](http://css.dzone.com/articles/errors-part-learning-curve)[Errors: part of the learning curve](http://css.dzone.com/articles/errors-part-learning-curve)
-   [![](http://i.zemanta.com/noimg_2_80_80.jpg)](http://www.modernperlbooks.com/mt/2012/08/why-i-use-perl-testing.html)[Why I Use Perl: Testing](http://www.modernperlbooks.com/mt/2012/08/why-i-use-perl-testing.html)
-   [![](http://i.zemanta.com/115656693_80_80.jpg)](http://blog.smartbear.com/software-quality/bid/201324/Divide-Your-Automated-Testing-Efforts)[Divide Your Automated Testing Efforts](http://blog.smartbear.com/software-quality/bid/201324/Divide-Your-Automated-Testing-Efforts)
-   [![](http://i.zemanta.com/noimg_71_80_80.jpg)](http://corfield.org/blog/post.cfm/automated-browser-based-testing-with-clojure)[Automated Browser-based Testing with Clojure](http://corfield.org/blog/post.cfm/automated-browser-based-testing-with-clojure)
-   [![](http://i.zemanta.com/noimg_113_80_80.jpg)](http://www.techwench.com/how-to-perform-software-automation-testing-step-by-step-tutorial/)[How to Perform Software Automation Testing - Step by Step Tutorial](http://www.techwench.com/how-to-perform-software-automation-testing-step-by-step-tutorial/)

[![Enhanced by Zemanta](http://img.zemanta.com/zemified_e.png?x-id=c3e2471f-2e38-487a-a839-306d9e4f87b9)](http://www.zemanta.com/?px "Enhanced by Zemanta")
