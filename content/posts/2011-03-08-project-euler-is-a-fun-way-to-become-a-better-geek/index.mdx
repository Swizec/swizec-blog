---
layout: post
title: 'Project euler is a fun way to become a better geek'
date: 2011-03-08
redirect_from: 
            - /blog/project-euler-is-a-fun-way-to-become-a-better-geek/swizec/1570
author: Swizec Teller
hero: ./img/wikipedia-commons-d-d7-Leonhard_Euler.jpg
---
\[caption id="" align="alignright" width="219" caption="Image via Wikipedia"][![By 1772, Leonhard Euler had proved that 2,147,...](./img/wikipedia-commons-d-d7-Leonhard_Euler.jpg "By 1772, Leonhard Euler had proved that 2,147,...")](http://commons.wikipedia.org/wiki/File:Leonhard_Euler.jpg)\[/caption]

Yesterday I was a bit bored at the Theoretical Basis Of Computer Science class and the obvious solution was to try doing a bit of coding on an algorithm I'm trying to develop that aims to learn the proper [syllabification](http://en.wikipedia.org/wiki/Syllabification "Syllabification") for a language by reading it. Because I'm all sorts of cool I want to develop this thing in [Clojure](http://clojure.org "Clojure"). Naturally, the moment I started my severe lack of proficiency in clojure started showing through and I found myself spending more time online than coding. Somehow I ended up on stackoverflow where some guy suggested to another guy they go through the [Project Euler](http://projecteuler.net/ "Project Euler") problem set to get better at Clojure. And so I did just that. Have only managed to solve the first three problems so far, but by god this crap is fun. Maybe I'm just being way too dorky, but it's #WINNING! Me being me, I've decided to motivate myself to solving these by posting a solution on this blog every time I solve a problem. Here are the first three, probably less than elegant, but they're mine and I love them!

```
;If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
;Find the sum of all the multiples of 3 or 5 below 1000.

(defn nums [max n]
  (loop [cnt (+ n n) acc [n]]
    (if (>= cnt max) acc
	(recur (+ cnt n) (concat acc [cnt])))))

(defn answer [max]
  (println (reduce + (set (concat (nums max 3) (nums max 5))))))

(answer 1000)
```

```
;Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
;1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
;By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

(defn term [p-2 p-1]
  (+ p-2 p-1))

(defn fib [max p-2 p-1 acc]
  (if (>= p-1 max) acc
      (fib max p-1 (term p-2 p-1) (concat acc [p-1]))))

(defn fibonacci [max p-2 p-1]
  (fib max p-2 p-1 [1]))

(defn bla [a]
  (if (even? a) a 0))

(defn answer [max]
  (reduce + (map #(if (even? %1) %1 0) (fibonacci max 1 2))))

(println (answer 4000000))
```

```
; The prime factors of 13195 are 5, 7, 13 and 29.
; What is the largest prime factor of the number 600851475143 ?

(defn any? [l]
  (reduce #(or %1 %2) l))

(defn prime? [n known]
  (loop [cnt (dec (count known)) acc []]
    (if (< cnt 0) (not (any? acc)) 	(recur (dec cnt) (concat acc [(zero? (mod n (nth known cnt)))]))))) (defn next-prime [primes]   (let [n (inc (count primes))]     (let [lk (if (even? (inc (last primes))) (+ 2 (last primes)) (inc (last primes)))]       (loop [cnt lk p primes] 	(if (>= (count p) n) (last p)
	    (recur (+ cnt 2) (if (prime? cnt p) (concat p [cnt]) p)))))))

(memoize next-prime)

(defn n-primes [n]
  (loop [cnt 1 p [2]]
    (if (>= cnt n) p
	(recur (inc cnt) (concat p [(next-prime p)])))))

(defn factor [n factors primes]
  (if (== n 1) factors
      (loop [p primes]
	(if (== 0 (mod n (last p))) (factor
				     (/ n (last p))
				     (concat [(last p)] factors)
				     p)
	    (recur (concat p [(next-prime p)]))))))

(println (factor 600851475143 [] (n-primes 1)))
```

The third one took particularly long to figure out because I was going about it all wrong. What I later realized was that I don't at all have to spend time finding the next prime for the sequence of already known primes because factorization doesn't have to be that complicated. Could just have gone through the number and anything it would divide by would already be a guaranteed prime.

###### Related articles

- [Algorithmic problem-solving at Project Euler](http://www.chicagonow.com/blogs/redeye-puzzler/2011/01/algorithmic-problem-solving-at-project-euler.html) (chicagonow.com)
- [Project Euler problem 191, or, how I learned to stop counting and love induction](http://jsomers.net/blog/project-euler-problem-191-or-how-i-learned-to-stop-counting-and-love-induction) (jsomers.net)
- [Learning functional/clojure programming - practical excersises?](http://stackoverflow.com/questions/2888041/learning-functional-clojure-programming-practical-excersises) (stackoverflow.com)
- [The Art of Problem Solving](http://webmaths.wordpress.com/2011/01/05/the-art-of-problem-solving/) (webmaths.wordpress.com)

[![Enhanced by Zemanta](http://img.zemanta.com/zemified_e.png?x-id=a5eeb452-e279-40b5-af44-b543f21f7cae)](http://www.zemanta.com/ "Enhanced by Zemanta")