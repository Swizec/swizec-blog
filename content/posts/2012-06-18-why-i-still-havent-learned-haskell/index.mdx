---
layout: post
title: Why I still haven't learned Haskell
date: 2012-06-18
categories: Functional programming, Haskell, Implementations, Java, Languages, Programming, Tools
author: Swizec Teller
hero: ./img/light-at-end.jpg
---

![Light at the end of the tunnel](./img/light-at-end.jpg "Light at the end of the tunnel") Short story: because I'm lazy. Long story is a bit more nuanced. It involves everything from how many hours there are in a day, how shiny the distractions are and having enough excuses to learn stuff.

## The right tool for the job

Possibly the biggest reason why I try out new technologies, get super excited, but then never learn them properly is the _Use The Right Tool For The Job_ mantra I've lived by ever since I stopped being a teenager and became bored of religious wars. At the end of the day, the client doesn't really care what technology you use, your users don't care about the technology either. They care about a working product that is maintainable, expandable and gives them a good [price/performance ratio](http://en.wikipedia.org/wiki/Price/performance_ratio "Price/performance ratio"). Now look at my life:

-   _Hey, can you make us a complex business-like website on [MySQL](http://en.wikipedia.org/wiki/MySQL "MySQL")?_ - Sure! -> django
-   _Hey, we need a glue layer between a bunch of services!_ - Awesome! -> node.js
-   _Hey, I need a script to munge this data into that data._ - Hooray! -> python
-   _Hey, can you do X with websites for us?_ - Yep! Finally something algorithmic, I can use [Haskell](http://en.wikipedia.org/wiki/Haskell_%28programming_language%29 "Haskell (programming language)") \\o/

Oh wait ... except I can't use Haskell. I'm charging you decent money for this, and I'm not really productive in Haskell yet. I can make some cool things with it, but it takes twice or thrice as long as using tools I'm familiar with. Of _course_ you don't want to spend that kind of money to fund my pet learning subject. For no obvious gain of course. I could just as easily do it in some other language. Except it would be cheaper to create, easier for you to maintain and I'd spend more time on the problem than battling an unknown tool. _But it wouldn't be as cool!_ Yeah ... oh and what's that? The best tool for the job happens to be a library that only works in Java? Great. And the vicious cycle just keeps repeating itself. Because I never know enough Haskell, Haskell never becomes the right tool for the job. There would have to be a _very very good_ reason that goes beyond "I love Haskell! It is the coolest language since forever!" to make me use Haskell on a paid-for project.

## Time

Right, but I could just learn Haskell in my own time couldn't I? Then I'd know it well enough and suddenly it would be the right tool for the job and everyone would live happily ever after. Well, no. I've tried that:

1.  [Learning me a Haskell](http://swizec.com/blog/learning-me-a-haskell/swizec/3272)
2.  [Raining datatypes](http://swizec.com/blog/sabbatical-week-day-3-raining-datatypes/swizec/3293)
3.  [A message from your future self](http://swizec.com/blog/a-message-from-your-future-self/swizec/3377)
4.  [Collatz, Haskell and memoization](http://swizec.com/blog/collatz-haskell-and-memoization/swizec/3382)
5.  [This Haskell is wrong, why?](http://swizec.com/blog/this-haskell-is-wrong-why/swizec/3489)
6.  [Lychrel numbers](http://swizec.com/blog/lychrel-numbers/swizec/3559)

Certainly not a lack of trying to learn Haskell. And I've learned a lot, don't get me wrong. It is most certainly my favourite language for implementing algorithms. But at the same time, I still haven't fully figured out monads and doing IO or anything actually too much useful ... it just doesn't come together. I mean, there's so many things to learn. So many things to do. There isn't enough time in the day to work on everything and learn everything that I want and love and find interesting. As unfortunate as it may be, _Solving The Problem_ mostly comes higher on my list of priorities than_Learn This Cool New Way Of Solving The Problem_.

###### Related articles

-   [![](http://i.zemanta.com/94679149_80_80.jpg)](http://stackoverflow.com/questions/3208258/memoization-in-haskell)[Memoization in Haskell?](http://stackoverflow.com/questions/3208258/memoization-in-haskell)

    * * *

-   [![](http://i.zemanta.com/88781041_80_80.jpg)](http://justtesting.org/gpu-accelerated-array-computations-in-haskell)[GPU accelerated arrays for Haskell](http://justtesting.org/gpu-accelerated-array-computations-in-haskell)

    * * *

-   [![](http://i.zemanta.com/noimg_00_80_80.jpg)](http://www.free-variable.org/2012/05/an-intro-to-haskell-for-ruby-programmers/)[An Intro to Haskell for Ruby Developers](http://www.free-variable.org/2012/05/an-intro-to-haskell-for-ruby-programmers/)

    * * *

-   [![](http://i.zemanta.com/noimg_08_80_80.jpg)](http://slidetocode.com/2012/04/09/why-i-prefer-scheme-to-haskell/)[Why I prefer Scheme to Haskell](http://slidetocode.com/2012/04/09/why-i-prefer-scheme-to-haskell/)

    * * *

-   [![](http://i.zemanta.com/noimg_11_80_80.jpg)](http://www.i-programmer.info/professional-programmer/i-programmer/3892-the-functional-view-of-the-new-languages.html)[The Functional View of the New Languages](http://www.i-programmer.info/professional-programmer/i-programmer/3892-the-functional-view-of-the-new-languages.html)

    * * *

[![Enhanced by Zemanta](http://img.zemanta.com/zemified_e.png?x-id=b8c535c5-2cdf-47f7-8371-444768f084df)](http://www.zemanta.com/?px "Enhanced by Zemanta")
