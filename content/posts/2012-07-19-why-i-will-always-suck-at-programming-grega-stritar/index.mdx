---
layout: post
title: 'Why I will always suck at programming [Grega Stritar]'
date: 2012-07-19
redirect_from: 
            - /blog/why-i-will-always-suck-at-programming-grega-stritar/swizec/4873
categories: 'Uncategorized'
author: Swizec Teller
hero: ./img/wikipedia-en-thumb-4-44-Treasure_Island_Dizzy.png-300px-Treasure_Island_Dizzy.png
---
I've been actively **coding for 15 years now**, ever since I've discovered the Interwebs. If you count in the lectures I took for [ZX Spectrum 48](http://en.wikipedia.org/wiki/ZX_Spectrum "ZX Spectrum - Wikipedia") during my elementary school, this range stretches to more than 20 years, but that was more fun than business. In this time, I've developed more than **50 different pieces of software**, mostly [business-oriented information systems](http://neolab.si/ "Neolab, software development"), majority of them successfully implemented. But I still **don't know shit about programming**, about different environments and technologies, methodologies and other technical fetishes. And I've accepted the fact this situation won't change any time soon, if ever.



\[caption id="" align="alignright" width="300" caption="The first screen of the Treasure Island Dizzy, ZX Spectrum version (Photo credit: Wikipedia)"][![The first screen of the Treasure Island Dizzy,...](./img/wikipedia-en-thumb-4-44-Treasure_Island_Dizzy.png-300px-Treasure_Island_Dizzy.png "The first screen of the Treasure Island Dizzy,...")](http://en.wikipedia.org/wiki/File:Treasure_Island_Dizzy.png)\[/caption]



When I see people like [Swizec](https://twitter.com/#!/swizec "Swizec (swizec) on Twitter") doing their [touring machines in hundred-something bytes in JavaScript](http://swizec.com/blog/a-turing-machine-in-133-bytes-of-javascript/swizec/3069 "A turing machine in 133 bytes of javascript"), I sadly have to admit that's something **I'm not able to reproduce**. While I am [truly impressed](http://i3.kym-cdn.com/entries/icons/original/000/006/151/tumblr_lltzgnHi5F1qzib3wo1_400.jpg "Not bad"), I know it would take me ages to understand what's happening, so I don't even try. Too hard core for me. In my world, the **essence lies somewhere else**.



I see **technology mostly irrelevant**. It's just the means that helps you achieve something bigger. Transformation of [real-life processes into abstract information processes](http://www.computerworld.com/s/article/9228471/Tech_hotshots_The_rise_of_the_IT_business_analyst "Tech hotshots: The rise of the IT business analyst"), developing software that**does what it's supposed to do**. That's the goal, and it doesn't really matter how yo get to it. In this context, I see the **database as the most \\important part** of every information system. If the data model is done properly, with [integrities and proper relationships](http://www.sqlmag.com/article/performance/sql-by-design-the-four-integrities "SQL By Design: The Four Integrities"), the **code doesn't stand a chance against it**. It can't fuck it up, it can't do much more or less than what it's supposed to do. It just makes it awesome or not.



But even if I see myself as a system (database) architect, that doesn't mean I don't **like to play**. I've developed a few **interesting prototypes** in the past years, but they were all on a "higher" level. Like having an abstract **super-entity** that all other objects are derived from. Or having a **meta-engine** that serves complex applications in a similar fashion than a CMS serves a website. Or having everything in a system defined by **EntityID - InstanceID** (eg. User - Grega or Company - Neolab), allowing secondary requirements, such as attaching files or adding notes, trivial. Or having a[mini-feed similar to Facebook's](http://stritar.net/Post/How_Mini_Feed_And_Other_Streams_Revolutionized_IT.aspx "How mini-feed and other streams revolutionized IT") to document every action in a system.



But this are all abstract things, that **don't have that much to do with programming**, even if they are coded. They are prototypes, serving as **proof of concept**, that are written poorly, and then usually **rewritten by someone else** who knows what he/she is doing, and from that point on, I mostly don't understand how they are working anymore. And I really don't mind. I try to **discover the boundaries of what can be done**, and since technology I work with supports that, I don't even try to learn new ones or study the advanced details of those I use ([asp.net](http://asp.net/) (c#) + MS SQL, if you're interested).



I think the real magic happens when **profiles like Swizec and I get together** (we haven't yet, though). That's when the synergies kick in. And it's situations like these that make me perfectly aware that I don't need to know much about programming to code well. And I can freely say that I will **always suck at programming**, and it's ok. Black boxes happen all the time, so I have to let go to go further. Writing my crappy code that does awesome shit even though you would probably laugh at it.



_[Grega Stritar](https://twitter.com/#!/gstritar "Grega Stritar (gstritar) on Twitter") is an entrepreneur, software architect, blogger and geek based in Ljubljana, Slovenia. He shares his thoughts on [stritar.net](http://stritar.net/Blog.aspx "Stritar's chronolog")._

[![Enhanced by Zemanta](http://img.zemanta.com/zemified_e.png?x-id=61e1139d-982b-47c3-b92a-72793b51d293)](http://www.zemanta.com/?px "Enhanced by Zemanta")